#### 协程的概念
- 定义：协程在执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行；注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。

或者这样理解：我们需要一个可以暂停的函数，并且可以在适当的时候恢复函数的继续执行因此出现协程，一个有多个入口的函数，可以暂停的函数（暂停的地方可以传入值）

#### 协程的特点、使用场景、优缺点
- 特点：
(1)单线程
(2)协程是函数级别的调用，可以由程序员的调度，线程与进程是计算机内核级别的调度
(3)传统消费者生产者模式，一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁，协程使用yield不需要加锁

- 与多线程比 协程的优势：
(1)协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显
(2)不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多
(3)与多进程结核，利用多核CPU，因为协程是一个线程执行，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能


#### 学习协程所需掌握的的背景知识：
1.了解传统生产者 消费者的相关知识
2.死锁的概念、产生场景、解决思路
3.yield与yield from的区别，后者的的运行流程
4.yield的close send throw方法
5.什么是生成器，生成器与协程的关系与演化
6.生成器是可以暂停的函数，使用inspect.getgeneratorstate())检测生成器的状态（convert_gen_to_coroutine.py）

#### 学习协程中需要理解掌握的知识点
1.协程的概念
2.协程演变过程中解决了哪些问题，使用场景有哪些
3.协程与多进程 多线程的对比，可以从哪个方面进行对比
4.协程与生成器之间的关系（可以看fluent Python 的How Coroutines Evolved from Generators此章节）
5.协程运用时使用的工具 插件  包 函数
6.yield from 相比yield的不同(diff_OF_yield_from_and_yield.py),掌握调用方，委托生成器，子生成器的概念
7.原生协程的诞生，目的意义，使用方法，与使用asyncio装饰器的协程有什么区别(asyncio_decorators_coroutines.py)


#### 协程相关的实例练习
1.使用yield协程实现传统消费者与生产者的模式(yield_producer_consumer.py)
2.使用asyncio装饰器实现协程(asyncio_decorators_coroutines.py)
3.原生协程(async_await.py), 把@asyncio.coroutine替换为async，把yield from替换为await，更多的原生协程编程可以参看[asyncio并发编程]



#### 推荐学习资料
- fluent Python
- 缪雪峰博客
