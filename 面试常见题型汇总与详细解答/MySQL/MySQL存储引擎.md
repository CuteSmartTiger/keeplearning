##### 谈谈MySQL数据库的引擎了解？
- 为什么要合理选择数据库存储引擎？
  - MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。
  - 这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。



- InnoDB
  - 介绍：InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别

  - 什么叫事务？
    - 事务指一些列SQL语句要么执行成功，要么执行不成功，事务的特性ACID
    - A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.
    - C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.
    - I 隔离性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.
    - D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚


  - 如果不进行事务隔离 ，会出现以下异常情况
    - 脏读（Dirty Read）：一个事务处理过程里读取了另一个未提交的事务中的数据，与非重复读的区别在于读到未提交事务中的数据
    - 非重复读(nonrepeatable read):一个事务重复读两次得到不同的结果，对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询的间隔期间，另外一个事务修改并提交了该数据。
    - 幻读(phantom read)：在一个事务中读取到了别的事务插入的数据，导致前后不一致，即一个事务第二次查出第一次没有的结果
    - 修改丢失(lost update)：并发写入造成其中一些修改丢失

  - 为了解决以上异常情况，定义了事务隔离的级别，如下：
    - 读未提交(read uncommitted)：别的事务可以读取到未提交改变
    - 读已提交(read uncommit):只能读取已经提交的数据
    - 可重复读(repeatable read)：同一个事务先后查询结果一样 (MySQL innoDB默认实现可重复读级别)
    - 串行化(serializable):事务完成串行化的执行，隔离级别最高，执行化效率最低

  - 四中隔离级别对应解决的问题，如表：
      |隔离级别 |脏读| 不可重复读    |幻读|
      | :--- | :---- | :------- |:----- |:----- |
      | 读未提交 | 可能  | 可能    |   可能   |
      | 读已提交 |  不可能 |   可能  |  可能    |
      | 可重复读 |不可能   |   不可能  |  可能    |
      | 串行化 |不可能  |    不可能 |    不可能  |

  - 锁
    - 悲观锁
      - 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）
    - [乐观锁](https://blog.csdn.net/qq_34337272/article/details/81072874)
      - 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现

  - 如何避免脏读？
    - 通过对数据加行锁或则表锁，使对同一数据进行操作的事务处于等待状态，来避免同时操作

  - 如何避免不可重复读？
    - [通过MVVC(多版本并发控制）实现事务的可重复读](https://www.jianshu.com/p/bcc614524024),也可以说通过乐观锁实现
    - MVVC在每一行记录的后面加两个隐含列（记录创建版本号和删除版本号）。这里的版本号指的是事务的版本号（每个事务启动的时候，都有一个递增的版本号）
    - 执行查询操作需要符合如下规则才能被查出来
      1. 删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。
      2. 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前
  - 如何避免幻读？
    - Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是Record Locks与Gap Locks的一个结合

- MyISAM
  - MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去

- InnoDB与MyISAM的对比(从以下方面理解：事务 锁 行数 索引存储 备份 性能)
  - 事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”就是说在不确定的范围时，InnoDB还是会锁表的。
  - 性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。
  - 行数保存。InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。
  - 索引存储。对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。
  - 服务器数据备份。InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。而且MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。
  - 锁的支持。MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的


- 使用建议：
  - 以下两点必须使用 InnoDB：
    1. 可靠性高或者要求事务处理，则使用InnoDB。这个是必须的。
    2. 表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定InnoDB数据引擎的创建。
  - MyISAM的使用场景：
    1. 做很多count的计算的。如一些日志，调查的业务表。
    2. 插入修改不频繁，查询非常频繁的。
  - 补充：MySQL能够允许你在表这一层应用数据库引擎，所以你可以只对需要事务处理的表格来进行性能优化，而把不需要事务处理的表格交给更加轻便的MyISAM引擎。对于 MySQL而言，灵活性才是关键。

- InnoDB和MyIsam索引结构
  - 聚集索引和非聚集索引
    1. 聚集还是非聚集指的是B+ Tree叶节点存的是指针还是数据记录
    2. myisam索引和数据分离，使用的是非聚集索引
    3. innoDB数据文件是索引文件，主键索引就是聚集索引
  - MyIASM引擎的索引结构：
    - MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引
    - 过程： MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，根据data域的值去读取相应数据记录
  - InnoDB引擎的索引结构：
    - B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。
    - InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。
    - 建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。
    - 因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。且，与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域
    - 过程：将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 13”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据


- MySQL索引原理及优化
  - 索引是数据表中一个或者多个列进行排序的数据结构
  - B-Tree
    - 线性查找：一个个找，实现简单；缺点：太慢
    - 二分查找：有序，简单；缺点：要求有序的，插入特别慢
    - HASH：查询快；缺点：占用空间，不太适合存储大规模数据
    - 二叉树查找：插入与查询很快；缺点：无法存超大规模数据，复杂度退化为线性查找
    - 二叉平衡树：解决bst退化的问题，树是平衡的；节点非常多的时候，依然树高很高
    - B Tree多路平衡查找树：多路平衡查找树
    - MySQL 实际使用B +Tree作为索引的数据结构:
      - 只在叶子节点带有指向记录的指针(为什么？ 可以增加树的度？)
      - 叶子节点通过指针相连。为什么？实现范围查询
  - 创建索引类型
    - 普通索引
    - 唯一索引
    - 多列索引
    - 主键索引
    - 全文索引 innoDB不支持
  - 什么时候创建索引？
    1. 经常用作查询条件的字段(where条件)
    2. 经常用作表连接的字段
    3. 经常出现在order by, group by之后的字段
  - 创建索引需要注意什么？
    - 非空字段 NOT NULL MySQL很难对空值做查询优化
    - 区分度高，离散度大，作为索引的字段值尽量不要有大量相同值
    - 索引的长度不要太长(比较耗费时间)
  - 索引什么时候失效？
    1. 以%开头的like语句，模糊搜索
    2. 出现隐士类型转换(Python 这种动态语言查询中需要的注意)
    3. 没有满足最左前缀原则(想想为什么是最左匹配？  多列索引时以元组作为索引，缺失时导致无法比较)
    - 总结：以上索引失效的最终原因为key无法比较

  -  如何排查慢查询？
    1. slow_query_log_file 开启并查询慢查询日志
    2. 通过explain排查索引问题
    3. 调整数据修改索引，业务代码层限制不合理访问

  - 索引的原理 类型 结构
  - 创建索引的注意事项 使用原则
  - 如何排查和消除慢查询




##### 参考好文章
- [mysql各种引擎对比、实战](https://www.cnblogs.com/sunsky303/p/8274586.html)（这篇文章非常好）

- [MySQL事务隔离级别的实现原理](https://www.cnblogs.com/cjsblog/p/8365921.html)
