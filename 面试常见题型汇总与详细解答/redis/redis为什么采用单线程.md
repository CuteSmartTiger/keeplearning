Redis效率高的主要原因有下面几个：
- 基于内存操作，速度非常快
- 采用单线程，避免了上下文的切换导致消耗CPU
- 采用单线程，不用去考虑各种加锁释放锁的问题
- 使用IO多路复用模型，非阻塞IO



举例说明：
由于Redis使用单线程来处理命令的，所以一条命令来了之后不会立即执行，而是将命令加到一个队列中，然后逐个被执行，这样就能保证在不加锁的情况下保证不会产生并发问题。
如果Redis采用多线程执行命令，那么对于三个连接同时执行incr操作的时候，就需要添加锁来保证线程的安全性了，会大大降低执行效率。
Redis采用非阻塞IO，使用epoll作为IO多路复用技术的实现，再加上Redis自身的树碱处理模型将epoll中的连接、读写、关闭都转为事件，不在网络IO上浪费过多的事件。
当然了，单线程机制也不是万能的，也会存在一个的问题：对于每个命令的执行事件是有要求的。如果某个命令执行事件过长，会导致其他命令被阻塞，对于Redis这种高性能的服务来说是致命的。
