#### 由浅到深准确深入理解TCP协议(面试)
##### 主问题：简述TCP三次握手？
1. 第一次握手：客户端主动向服务端发起，Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，SYN=0，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了

注意要点：
1. 主动发起者是客户端，服务端被动响应，为什么服务端不能主动发起了？
2. 每一次握手时，标志位的值，序列号的值，服务端与客户端的状态
3. SYN=1出现在在第一次与第二次握手时，表示发起方需要建立连接向接收方发送信息


##### 由主问题衍生出的子问题1：三次握手中相关标志位的字母缩写是哪些单词的缩写，含义是什么？
- 标志位 共6个，即URG、ACK、PSH、RST、SYN、FIN
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接


- SYN
  - 英文全称：synchronous  同步
  - 同步连接序号，TCP报文就是把SYN这个标志设置为1，来请求建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，其他标记位暂无赋值；连接被响应的时候，服务端发送SYN=1，ACK=1，当第一次握手时，当客户端向服务端请求建立连接向服务端发送数据时，SYN被置为1，当第二次握手时，服务端响应请求，并将SYN置为1，请求向客户端发送数据，TCP为双端通信
- ACK
  - 英文全称：acknowledgement 确认  简写为ACK，注意与ack区别
  - ACK为请求/应答状态,标记为1响应成功


- seq
  - 英文全称：Sequence number  序号
  -

- ack或Ack   
  - 英文全称：Acknowledge number  确认序号
  - seq+1


##### 由主问题衍生出的子问题2：TCP握手为什么是三次而不是四次？
- 关键点：TCP协议是全双工通信
- 第一、二次握手确认了客户端可以向服务端发送消息，并且服务端可以接收到信息
- 为了实现双端通信，服务端需要发送信息给客户端并得到客户端的确认信息后，才可以给客户端发送信息，这又需要两次握手
- 为了节省网络资源，将第三次与第四次握手合并，将需要四次握手简化为三次握手，通过抓包工具我们会发现在TCP第二次握手时，服务端除了回复ACK=1外，标记SYN=1，创建服务端到客户端传输信息的通道



##### 由主问题衍生出的子问题3：TCP为什么不是两次握手？
- 原因：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
- 详细解释为：已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源


##### 由主问题衍生出的子问题3：三次握手时客户端与服务端的状态转变？





##### TCP四次挥手过程？
1. 第一次挥手：客户端发送一个FIN=1，用来关闭客户端到服务器端这个方向的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

2. 第二次挥手：服务器端收到FIN后，先发送ack=u+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息（服务端会等待没有发送的数据发送完毕）。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

3. 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=1报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

4. 第四次挥手：客户端收到FIN=1报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=w+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传，服务器端收到ACK后，就知道可以断开连接了。现在TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL(2倍最大报文存活时间)后，客户端才进入到CLOSED状态，服务器端收到ACK后，就知道可以断开连接了。最终完成了四次握手。

注意要点：
- 每一次挥手后客户端与服务端的状态
- 客户端第四次挥手后并没有立即关闭，而是等待2MSL后才关闭，服务端在第四次挥手后确认收到ACK=1后关闭服务端


##### 由主问题衍生出的子问题1：解释一下FIN
- 标志位的FIN  finish   发起释放连接 出现在第一次与第四次挥手中



##### 由主问题衍生出的子问题2：为什么不是三次挥手(将第二次挥手与第三次挥手合并)？
- 关键点：全双工通信
- 关闭连接时，当服务端收到对方客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。


##### 由主问题衍生出的子问题3：四次挥手释放连接时，等待2MSL的意义？
- MSL 是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
- 第一，为了保证客户端发送的最后一个ACK报文段能够到达，因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务端收不到ACK对FIN报文段的确认。服务端会超时重传这个FIN，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段，接着A重传一次确认，否则B收不到ACK会出现关闭异常。
- 第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失



##### 由主问题衍生出的子问题4：为什么服务端不在第三次挥手时关闭？
- 若第三次挥手服务端直接关闭，那么因为网络因素客户端没有收到来自服务端的FIN,那么C端会一直等待FIN，这时服务端已经关闭了将导致客户端端无法关闭


##### 由主问题衍生出的子问题5：为什么在四次挥手的过程中一般都是客户端先发起呢？
- 关键点在于：TCP挥手时要等2MSL
- 现象：在调试客户端和服务器端（使用TCP套接字）的代码时，如果先结束服务器端后结束客户端，紧接着再重启服务器端就会出现绑定失败的错误 OSError: [Errno 98] Address already in use   等待一段时间后大概一分钟左右就能正常重启服务器端
- 分析：
- 因为TCP是全双工的，所以客户端和服务端都可以先进行挥手。在socket编程中哪一方先执行close()操作，哪一方则先进行挥手（发送FIN包）。
- 以客户端先挥手为例，在TCP处于TIME_WAIT状态时，客户端从TIME_WAIT状态到CLOSED状态需要2MSL，因为客户端要确定服务端收到了ACK，如果服务端没收到ACK，客户端则一定会在2MSL时间内再收到一次FIN。而在socket编程中客户端一般不需要绑定，而服务器端一般都要绑定，如果先结束服务器端则是服务器端先进行挥手操作，那么服务器端从TIME_WAIT到CLOSED状态则需要2MSL。这段时间服务器端绑定的端口号被占用了，套接字不会释放。所以这段时间重启了服务器之后，会出现绑定失败的错误OSError: [Errno 98] Address already in use

##### 由主问题衍生出的子问题5：四次挥手时客户端与服务端的状态转变？




##### TCP滑动窗口协议
- 先理解一个过程：A为客户端，B为服务端，首先是AB之间三次握手建立TCP连接。在报文的交互过程中，A将自己的缓冲区大小（窗口大小）3发送给B，B同理，这样双方就知道了对端的窗口大小。A开始发送数据，A连续发送3个单位的数据，因为他知道B的缓冲区大小。在这一波数据发送完后，A就不能再发了，需等待B的确认。A发送过来的数据逐渐将缓冲区填满。这时候缓冲区中的一个报文被进程读取，缓冲区有了一个空位，于是B向A发送一个ACK，这个报文中指示窗口大小为1。A收到B发过来的ACK消息，并且知道B将窗口大小调整为1，因此他只发送了一个单位的数据并且等待B的下一个确认报文
- [滑动窗口协议](https://san-yun.iteye.com/blog/1972775):发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速 度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。下面图中的4,5,6号数据帧已经被发送出去，但是未收到关联的 ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必须考虑拥塞窗口cwnd，这里暂且考虑 cwnd>rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10 也可以被发送


#### 参考靠谱的文章
- [带你了解TCP/IP协议族](https://segmentfault.com/a/1190000018173947)
- [TCP/IP协议简述+常见面试题](https://blog.csdn.net/Summer_Lyf/article/details/84024072)
