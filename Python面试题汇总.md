#### 基础概念

- GIL解释器锁
  - 线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢


- 协程  

- 不可重复的数据结构
- 深拷贝与浅拷贝
  - 浅拷贝
    - 直接赋值,默认浅拷贝传递对象的引用而已,原始列表改变，被赋值的b也会做相同的改变
    - copy.copy()浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变
  - 深拷贝
    - 深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变

- 如何传参
  - 传递的是对象，而不是变量或者指针
  - 对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)
  - 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.

- 判断对象是否存在属性或者方法
  - hasattr
  - getattr
  - setattr

- 单例模式  了解 super指定起始查找点，顺着MRO查找第二个参数  new拦截类的实例化  init创建实例后初始化值   call实现可调用

- 回调    web  start_response

- 函数式编程
  - map
  - filter
  - reduce
  - 闭包
    - 绑定外部作用域的变量的函数
    - 即使程序离开外部作用域，如果闭包仍然可见，绑定变量不会销毁
    - 每次运行外部函数都会重新创建闭包


- Python2与Python3的区别

#### 数据结构与算法
- 二分查找
- 哈希查找
- 分块查找
- 顺序查找

- 顺序排序
- 插入排序
- 冒泡排序
- shell排序
- 快速排序
- 基数排序
- 二路并归排序



#### Linux
- 常用命令
  - 帮助
    man  tar
    tar --help
    tldr

```SHELL
chown chmod chgrp
ls/rm/cd/cp/mv/touch/rename/ln(软连接与硬链接)
lcate find grep
find . -name '*.pyc' -delete
```

vi/nano
cat/head/tail
more/less


进程相关

ps
kill  执行的原理   发送信号


top/htop


内存
free


网络工具
ifconfig
lsof/netstat 查看端口
ssh/scp    tcpdump抓包


useradd/usermod
groupadd/groupmod




#### 线程  进程  协程





#### 网络编程
- 网络协议TCP和UDP
  - 浏览器输入一个url中间经历的过程:
    1. DNS查询      
    2. TCP握手      wireshark抓包更直观 重点有两点(状态与发包内容)  手画图     
    3. HTTP请求     携带的信息包
    4. 反向代理     Nginx
    5. uwsgi       服务器
    6. web app   （flask框架）
    7. TCP挥手    为什么是四次而不是三次或者五次

  - TCP与UDP的区别
    - 面向连接  可靠地  基于字节流
    - 无连接  不可靠   面向报文

- DNS查询      
  - 查询过程：缓存查询与域名服务器查询
     -  浏览器缓存:当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；
     - 系统缓存:当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；
     -  路由器缓存:当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；
     -  ISP（互联网服务提供商）DNS缓存:当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；
     -  根域名服务器:当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本
     - 顶级域名服务器:顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；
     -  主域名服务器:主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；
     -  保存结果至缓存:本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。
  - 为什么使用UDP协议进行DNS查询
    - 网络资源角度：基于UDP的DNS协议只要一个请求、一个应答就可以了，而使用基于

- TCP协议
  -  面向连接  可靠地  基于字节流


  4. [为什么在四次挥手的过程中一般都是客户端先发起呢?](https://blog.csdn.net/Daputao_net/article/details/81255499)

    - 关键点在于：TCP挥手时要等2MSL
    - 现象：在调试客户端和服务器端（使用TCP套接字）的代码时我发现，如果先结束服务器端后结束客户端，紧接着再重启服务器端就会出现绑定失败的错误 OSError: [Errno 98] Address already in use   等待一段时间后大概一分钟左右就能正常重启服务器端
    - 分析：
    - 因为TCP是全双工的，所以客户端和服务端都可以先进行挥手。在socket编程中哪一方先执行close()操作，哪一方则先进行挥手（发送FIN包）。
    - 以客户端先挥手为例，在TCP处于TIME_WAIT状态时，客户端从TIME_WAIT状态到CLOSED状态需要2MSL，因为客户端要确定服务端收到了ACK，如果服务端没收到ACK，客户端则一定会在2MSL时间内再收到一次FIN。而在socket编程中客户端一般不需要绑定，而服务器端一般都要绑定，如果先结束服务器端则是服务器端先进行挥手操作，那么服务器端从TIME_WAIT到CLOSED状态则需要2MSL。这段时间服务器端绑定的端口号被占用了，套接字不会释放。所以这段时间重启了服务器之后，会出现绑定失败的错误OSError: [Errno 98] Address already in use


  5. tcp长连接和短连接
  - TCP长/短连接的优点和缺点:
  - 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。
  - client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损,如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
  - 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
  - 但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。
  - TCP长/短连接的应用场景：
  - 数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费
  - 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源
  - 如何区分：请求头中有：Connection: keep-alive



- [HTTP协议](https://www.cnblogs.com/ranyonsue/p/5984001.html)
  - pip install httpie  
  - curl
  - HTTP协议有哪些部分组成  使用抓包工具去查看和理解
    - HTTP请求
      - 状态行
      - 请求头
      - 消息主体
    - HTTP响应
      - 状态行
      - 响应头
      - 响应正文
    - HTTP响应状态码  五中类型
  - 幂等性  GET
  - 长连接
    - 为什么需要长连接
    - 如何区分短还是长连接
      - 1. content-Length 携带报文长度
      - 2. Transfer-Encoding:chunked
  - cookie与session的区别，识别用户
  - 前后端分离如何识别用户状态
  - 本节重点内容：
    - 请求和响应的组成
    - 常用HTTP方法和幂等性
    - 长连接 session  cookie

- socket编程原理
  - TCP编程


- 并发编程IO多路复用


- 并发网络库


- 异步框架


- WSGI与web框架
  - WSGI 是什么    解决什么问题
    - uWSGI uWSGI是一个web服务器，实现了WSGI协议，uwsgi协议，http协议等。
    - uwsgi  是一种协议
  - web框架的组成(基础重点) 尝试自己编写一个web服务器
    - 中间件 用于请求之前和请求之后做一些处理
    - 路由  表单验证 权限认证 ORM 视图函数  模板渲染  序列化
    - redis   RESTful

- RESTful
  - 前后端分离意义及方式
  - 什么是RESTful   怎么设计RESTfu
    - 表现层状态转移 其中表现层指资源的表现形式，图片  文本；
    - 资源(Resource) 使用URI指向的一个实体
    - 一种以资源为中心的web软件架构风格
  - 如何理解资源

- RESTful API
  - 三部分组成
    - HTTP方法GET、DELETE、POST和PUT操作资源
    - json
    - RESTful API插件
- 如何设计RESTful API
    - 使用名字而不是动词，名词使用复数而不是单数
    - 同一资源可以有一组操作
      - GET   http://[hostname]/api/users  检索用户列表
      - GET   http://[hostname]/api/users/[id]  查询单个用户
      - POST  http://[hostname]/api/users     创建用户
      - PUT   http://[hostname]/api/users/[id]  修改用户
      - DELETE  http://[hostname]/api/users/[id]  删除用户
    - 定义返回状态码



- cookie
  1. 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据,cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。
- session
  1. 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全
  - 缺点：
  1. Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。
  2. 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题，如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失
- token 签名加密
  1. Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
  2. Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
  3. 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

#### 设计模式
- 装饰器模式
- 观察着模式
- 单例模式
- 工厂方法
- 抽象工厂
- 代理模式


#### web安全
