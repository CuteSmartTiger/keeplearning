####  fork 操作
同步操作
与内存量息息相关：内存越大，耗时越长（与机器内型有关）
info:latest_fork_usec

改善fork：
1.优先使用物理机或者高效支持fork操作的虚拟化技术
2.控制redis实例最大可用内存：maxmemory
3.合理配置Linux内存分配策略：vm.overcommit_memory=1
4.降低fork频率：例如放宽AOF重写自动触发机制，不必要的全量重复


[fork优化其他参考资源](https://www.cnblogs.com/yangmingxianshen/p/8407972.html)

#### 子进程开销与优化
1.CPU
开销：PRDB和AOF文件生成，属于CPU密集型
优化：不做CPU绑定，不和CPU密集型部署
1）CPU开销分析
子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%。
2）CPU消耗。
Redis是CPU密集型操作，不要做绑定单核CPU的操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。

不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。
如果部署多个Redis实例，尽量保证同一时刻只有一个子进程执行重写工作。


2.内存
开销：fork内存开销，copy-on-write
优化：echo never > /sys/kernel/mm/transparent_hugepage/enabled

（1）内存消耗分析
子进程通过fork操作产生，占用内存大小等同于父进程，理论上需要两倍的内存来完成持久化的操作，但是Linux有写时复制机制。

父进程会共享相同的物理内存页，当父进程处理写请求时会把要修改的页创建副本，而子进程在fork操作过程中共享整个父进程内存快照。

（2）内存消耗监控
如果重写过程中存在内存页操作，父进程负责创建所修改内存页的副本，从日志中
父进程维护页副本消耗同RDB重写过程类似，不同之处在于AOF重写需要AOF重写缓冲区。

提示：编写shell脚本根据Redis日志可快速定位子进程重写期间内存过度消耗的情况。


3. 硬盘
开销：AOF和RDB文件写入，可以结合iostat，iotop分析
优化：
（1）不要与高硬盘负载服务器部署一起：存储服务，消息队列等
（2） no-appendfsync-on-rewrite = yes
（3）根据写入量决定磁盘类型：例如ssd
（4）单机多实例持久化文件目录可以考虑分盘


#### AOF追加阻塞
1.阻塞流程分析：

（1）主线程负责写入AOF缓冲区。

（2）AOF线程负责每秒执行一次同步操作，并记录最近一次同步时间。

（3）主线程负责每秒执行一次同步磁盘操作，并记录最近一次同步时间。

如果距上次同步成功时间在2秒内，主线程直接返回。
如果距上次同步时间超过两秒，主线程将会阻塞，直到同步操作完成。


通过分析AOF阻塞流程可以发现两个问题：

（1）everysec配置最多可能丢失2秒数据，不是1秒。

（2）如果系统fsync缓慢，将会导致Redis主线程阻塞影响效率。



2.AOF阻塞问题定位

（1）发生AOF阻塞问题，Redis会在日志中记录其行为。

（2）每当发生AOF追加阻塞事件，在info Persistence统计中，aof_delayed_fsync指标会累加，查看这个指标方便定位AOF阻塞问题。

（3）AOF同步最多允许2秒延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如iotop，定位消耗硬盘IO资源的进程。





单机多实例部署
